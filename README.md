# CS-350
Q: Summarize the project and what problem it was solving.
A:  The objective was to develop code that enables thermostat functionality on a TI Launchpad board. As per the project requirements, the implementation utilizes states and a task scheduler. The states involved in the project are the heater's on and off states and button states that adjust the temperature set point. Meanwhile, the task scheduler ensures proper logic execution at specified intervals.
Q: What did you do particularly well?
A: Given the resources, the task scheduler was done as specified and could be modified to handle more than required. The states are also handled well using a switch case for the buttons, and the heater functionality switches between on or off correctly. The code developed around the provided code is modular as well.
Q: Where could you improve?
A: Two oversights existed before this release. The statement handling the heater states was unintentionally reversed. The other oversight needed to remember to add the copyright back in, as was done with other projects for this course.
Q: What tools and/or resources are you adding to your support network? 
A: Documentation is always vital when working with unfamiliar source code or new languages. I donâ€™t have anything specific that will be added due to this course, as I do not intend to work with embedded systems outside of mobile development.
Q: What skills from this project will be particularly transferable to other projects and/or course work?
A: The state machines explored and the task scheduler may be helpful in game development. Otherwise, the development was similar to that of other courses. My process remained unchanged after the completion of the course. Generally, that process starts with understanding the inputs and outputs. After, I implement basic functionality as simply as possible before looking into modularizing the code.
Q: How did you make this project maintainable, readable, and adaptable?
A: The key aspects to make the project maintainable come from good documentation, modularity, and comments elaborating on each step. Attribute and method naming conventions were followed, ensuring the code could be read plainly.

